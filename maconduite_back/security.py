"""
This module provides security for the Flask application.

Specifically, it provides a session mechanism and Role-Based Access Control (or RBAC) with
JSON Web Tokens (or JWT). These tokens are encoded in the function generate_token(), and
are decoded in the decorator @auth_required.

Here is how it works : 
(1) A user makes a POST request to /auth/login/<role> with a JSON body containing its
email and password. There are only 3 roles:
- if the user is an Admin  → POST /auth/login/admin
- if the user is a Client  → POST /auth/login/client

(2) The server responds with a JSON Web Token (or access token) certifying that the user
has been authenticated with a specific role. This access token is generated by the function
generate_token().

(3) When a user makes subsequent requests to a protected route (i.e. a route that requires
authentication), he includes its access token in the JSON body of the request.

(4) The servers checks that the user is authenticated and that he's allowed to access this
protected route based on its role. This is done in the decorator @auth required.

The RBAC rules are simple:
- if the user is an Admin  → he can access all Sessions
- if the user is a Client  → he can access only his Sessions
"""
from datetime import datetime, timedelta
import logging
import jwt
from functools import wraps
from http import HTTPStatus
from flask import Blueprint, request, jsonify, abort, Response, current_app


logger = logging.getLogger(__name__)

def generate_token(public_id, role):
    """Generate an access token for the user.

    The token is a JSON Web Token (or JWT), and it contains user information cryptographically
    signed by the server (i.e. with the server JWT_SECRET_KEY). Therefore, the contents of
    the token are readable by everyone, but no one can forge a similar token.
    See also: https://jwt.io/introduction

    Parameters:
        public_id (int) : the public id of the user whom we generate the token for.
        role (string)   : can be 'client' or 'admin'.
                          This role determines what the user will have access to.

    Returns:
        string: the token (e.g. 'eyJhbGciOiJIUz.I1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiO')

    Details:
        On https://jwt.io/ you can paste a token and see its content or check the signature.
    """
    expiration_date = (
        datetime.now() + timedelta(hours = current_app.config['JWT_EXP_DELTA_HOURS'])
    )
    logger.info(f'access token expiration date : {expiration_date}')
    token_contents = {
            'public_id' : public_id,
            'exp'       : expiration_date,
            'role'      : role,
    }
    token = jwt.encode(
        payload   =token_contents,
        key       =current_app.config['JWT_SECRET'],
        algorithm =current_app.config['JWT_ALGORITHM'],
    )
    return token


def auth_required(authorized_roles=['admin', 'client']):
    """Decorator for ensuring authentication and RBAC on a Flask route.
    
    The wrapper looks for the access token, provided in the Authorization header.
    It then decodes the token, and feeds it to the wrapped route.

    A protected route is a route which require authentication and Role-Based Access-Control.
    There are many protected routes in this API (in fact almost all of them, except /register).

    But we don't want to implement authentication and RBAC *inside* a route,
    We want a generic protection function, able to protect any route, that we can add or
    remove on a route whenever we like. → Such a function is called a decorator.

    A decorator returns another function, after some verifications.
    In this case, we want a decorator that returns a Flask route, after performing the
    authentication and RBAC.

    See also:
    https://realpython.com/primer-on-python-decorators/
    https://blog.miguelgrinberg.com/post/the-ultimate-guide-to-python-decorators-part-iii-decorators-with-arguments

    Parameters:
        route (function): a Flask route i.e. a function decorated with @Flask.route
            See also https://flask.palletsprojects.com/en/2.0.x/api/#flask.Flask.route

    Returns:
        func: the function wrapper

    Details:
        (!) Flask requires to associate a single 'view function' with an 'endpoint'.
        This is compromised when we use a decorator on a Flask route,
        because a decorator overwrites the name of the wrapped function at runtime.
        (more specifically, it overwrites the attribute __name__, among others).

        So when we define two Flask routes:

        @app.route('/api/r1')
        @decorator
        def route_1()

        @app.route('/api/r2')
        @decorator
        def route_2()

        At runtime they will both be renamed 'decorator', and thus they will define the
        endpoint 'api.decorator', instead of defining two endpoints 'api.route_1' and
        'api.route_2'.

        Hence we will get this Flask error:
        `AssertionError:
        View function mapping is overwriting an existing endpoint function: api.decorator`

        To prevent this, we use the tool @wraps from functools.
        @wraps updates the wrapped function name at runtime, after it has been decorated.
        
        This way, route names are preserved and Flask endpoints are different.

        See also https://stackoverflow.com/a/42254713/6402299
        See also https://docs.python.org/3/library/functools.html#functools.wraps
    """

    @wraps(authorized_roles)
    def inner_decorator(route):

        @wraps(route)
        def wrapper(*args, **kwargs):
            try:
                logger.info('Verifying access token...')

                found_token = request.headers['Authorization'].split('Bearer ')[1]
                # logger.info(f'Found access token: {found_token}')

                decoded_token = jwt.decode(
                    found_token,
                    current_app.config['JWT_SECRET'],
                    current_app.config['JWT_ALGORITHM']
                )
                logger.info(f'Decoded access token: {decoded_token}')

                assert 'exp' in decoded_token
                assert 'public_id' in decoded_token
                assert decoded_token['role'] in ['admin', 'client']
                assert decoded_token['role'] in authorized_roles

            except (
                KeyError, IndexError, AssertionError, jwt.exceptions.InvalidTokenError
            ) as err:
                logger.exception(f'Unauthorized: {err}')
                abort(Response(
                    f'Unauthorized: invalid access_token.',
                    HTTPStatus.UNAUTHORIZED
                ))

            return route(decoded_token, *args, **kwargs)

            # NOTE: if an exception is raised here, it means that the protected route did
            # not implement a proper {try/except all}. Exceptions should not arise here.
            # except Exception as err:
            #     logger.exception(f'ERROR: unexpected exception in @auth_required ({err})')
            #     abort(Response(
            #         f'Unauthorized: invalid access_token.',
            #         HTTPStatus.UNAUTHORIZED
            #     ))

        return wrapper
    return inner_decorator